#!/usr/bin/env python3
import datetime
import json
import logging
import os
import multiprocessing

import click

from wildfire import goes
from wildfire.threshold_model import model

DATETIME_FORMATS = ["%Y-%m-%dT%H:%M:%S"]
PERSIST_FILENAME = "wildfires_{satellite}_{region}_s{start}_e{end}_c{created}.json"

logging.basicConfig(level=logging.INFO)
_logger = logging.getLogger(__name__)


@click.command()
@click.argument("satellite", type=click.Choice(["G16", "G17"]))
@click.argument("region", type=click.Choice(["M1", "M2", "C", "F"]))
@click.argument("start", type=click.DateTime(formats=DATETIME_FORMATS))
@click.argument("end", type=click.DateTime(formats=DATETIME_FORMATS))
@click.argument("max_scans_per_hour", type=int)
@click.argument("persist_directory", type=click.Path(exists=True, file_okay=False))
def label_wildfires(satellite, region, start, end, max_scans_per_hour, persist_directory):
    """Label GOES satellite data matching parameters with wildfires.

    `bin/label_satellite_data G16 M1 2019-01-01T01:00:00 2019-02-01T01:11:00 5 labeled_data`

    SATELLITE must be in the set (G16, G17). e.g. G16\n
    REGION be in the set (M1, M2, F, C). e.g. M1\n
    START must be in the following format: YYYY-MM-DDTHH:MM:SS. e.g. 2019-01-01T10:55:30\n
    END must be in the following format: YYYY-MM-DDTHH:MM:SS. e.g. 2019-01-01T10:55:30\n
    MAX_SCANS_PER_HOUR an integer limiting the number of scans to get per hour. e.g. 5\n
    PERSIST_DIRECTORY is a path to a local directory at which to persist scans. Directory
    must already exist. e.g. ./downloaded_data\n
    """
    _logger.info(
        """Downloading available GOES satellite data fulfilling parameters:
    Satellite: %s
    Region: %s
    Start Time: %s
    End Time: %s""",
        satellite,
        region,
        start,
        end,
    )
    goes_sequence = goes.get_goes_sequence(
        satellite=goes.utilities.SATELLITE_CONVERSION[satellite],
        region=region,
        start_time_utc=start,
        end_time_utc=end,
        max_scans_per_hour=max_scans_per_hour,
    )
    _logger.info("Finding wildfires in sequence...")
    wildfires = goes.utilities.pool_function(has_wildfire, goes_sequence.scans.values())
    wildfires_serialized = dict(enumerate(filter(None, wildfires)))

    if wildfires_serialized:
        _logger.info("Writing wildfires to disk...")
        with open(
            os.path.join(
                persist_directory,
                PERSIST_FILENAME.format(
                    satellite=satellite,
                    region=region,
                    start=start.strftime(DATETIME_FORMATS[0]),
                    end=end.strftime(DATETIME_FORMATS[0]),
                    created=datetime.datetime.utcnow().strftime(DATETIME_FORMATS[0])
                )
            ),
            "w+",
        ) as buffer:
            json.dump(wildfires_serialized, buffer)

    _logger.info("Success. Found %s scans with wildfires.", len(wildfires_serialized))


def has_wildfire(goes_scan):
    """Use the threshold model to determine if there is a wildfire in the scan.

    Parameters
    ----------
    goes_scan: wildfire.goes.scan.GoesScan

    Returns
    -------
    dict
    """
    _logger.info("Finding wildfire in scan...")
    model_features = model.get_features(goes_scan=goes_scan)
    model_predictions = model.predict(
        is_hot=model_features.is_hot,
        is_cloud=model_features.is_cloud,
        is_night=model_features.is_night,
        is_water=model_features.is_water,
    )
    is_wildfire_predicted = model_predictions.mean() > 0
    if is_wildfire_predicted:
        return {
            "region": goes_scan.region,
            "satellite": goes_scan.satellite,
            "scan_time_utc": goes_scan.scan_time_utc.strftime(DATETIME_FORMATS[0]),
        }
    return None


if __name__ == "__main__":
    label_wildfires()
